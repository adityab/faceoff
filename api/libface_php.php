<?php

/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.4
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

// Try to load our extension if it's not already loaded.
if (!extension_loaded('libface_php')) {
  if (strtolower(substr(PHP_OS, 0, 3)) === 'win') {
    if (!dl('php_libface_php.dll')) return;
  } else {
    // PHP_SHLIB_SUFFIX gives 'dylib' on MacOS X but modules are 'so'.
    if (PHP_SHLIB_SUFFIX === 'dylib') {
      if (!dl('libface_php.so')) return;
    } else {
      if (!dl('libface_php.'.PHP_SHLIB_SUFFIX)) return;
    }
  }
}



abstract class libface_php {
	const LibFace_VERSION_MAJOR = LibFace_VERSION_MAJOR;

	const LibFace_VERSION_MINOR = LibFace_VERSION_MINOR;

	const DEBUG = DEBUG;

	const OPENCVDIR = OPENCVDIR;

	const CONFIG_XML = CONFIG_XML;

	static function NowTime() {
		return NowTime();
	}

	const libfaceERROR = 0;

	const libfaceWARNING = libfaceWARNING;

	const libfaceINFO = libfaceINFO;

	const libfaceDEBUG = libfaceDEBUG;

	const ALL = 0;

	const DETECT = DETECT;

	const EIGEN = EIGEN;

	const HMM = HMM;

	static function faceAt($v,$index) {
		$r=faceAt($v,$index);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (!class_exists($c)) {
				return new Face($r);
			}
			return new $c($r);
		}
		return $r;
	}

	static function new_intP() {
		return new_intP();
	}

	static function copy_intP($value) {
		return copy_intP($value);
	}

	static function delete_intP($self) {
		delete_intP($self);
	}

	static function intP_assign($self,$value) {
		intP_assign($self,$value);
	}

	static function intP_value($self) {
		return intP_value($self);
	}

	static function new_FaceP() {
		$r=new_FaceP();
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (!class_exists($c)) {
				return new Face($r);
			}
			return new $c($r);
		}
		return $r;
	}

	static function copy_FaceP($value) {
		$r=copy_FaceP($value);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (!class_exists($c)) {
				return new Face($r);
			}
			return new $c($r);
		}
		return $r;
	}

	static function delete_FaceP($self) {
		delete_FaceP($self);
	}

	static function FaceP_assign($self,$value) {
		FaceP_assign($self,$value);
	}

	static function FaceP_value($self) {
		$r=FaceP_value($self);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (!class_exists($c)) {
				return new Face($r);
			}
			return new $c($r);
		}
		return $r;
	}
}

/* PHP Proxy Classes */
class Log {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_libface_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_libface_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __construct($res=null) {
		if (is_resource($res) && get_resource_type($res) === '_p_libface__Log') {
			$this->_cPtr=$res;
			return;
		}
		$this->_cPtr=new_Log();
	}

	function Get($level=null) {
		switch (func_num_args()) {
		case 0: $r=Log_Get($this->_cPtr); break;
		default: $r=Log_Get($this->_cPtr,$level);
		}
		return $r;
	}

	static function ReportingLevel() {
		return Log_ReportingLevel();
	}

	static function ToString($level) {
		return Log_ToString($level);
	}

	static function FromString($level) {
		return Log_FromString($level);
	}
}

abstract class LibFaceRecognitionCore {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_libface_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_libface_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}
	function __construct($h) {
		$this->_cPtr=$h;
	}

	function getConfig() {
		return LibFaceRecognitionCore_getConfig($this->_cPtr);
	}

	function loadConfig($config_or_dir) {
		return LibFaceRecognitionCore_loadConfig($this->_cPtr,$config_or_dir);
	}

	function saveConfig($dir) {
		return LibFaceRecognitionCore_saveConfig($this->_cPtr,$dir);
	}

	function update($dataVector) {
		return LibFaceRecognitionCore_update($this->_cPtr,$dataVector);
	}

	function recognize($test) {
		return LibFaceRecognitionCore_recognize($this->_cPtr,$test);
	}

	function count() {
		return LibFaceRecognitionCore_count($this->_cPtr);
	}
}

abstract class LibFaceDetectCore {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_libface_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_libface_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}
	function __construct($h) {
		$this->_cPtr=$h;
	}

	function detectFaces($filename_or_inputImage) {
		$r=LibFaceDetectCore_detectFaces($this->_cPtr,$filename_or_inputImage);
		if (!is_resource($r)) return $r;
		switch (get_resource_type($r)) {
		case '_p_std__vectorT_libface__Face_p_t': return new FacePVector($r);
		default: return new FacePVector($r);
		}
	}

	function accuracy() {
		return LibFaceDetectCore_accuracy($this->_cPtr);
	}

	function setAccuracy($value) {
		LibFaceDetectCore_setAccuracy($this->_cPtr,$value);
	}
}

class Face {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_libface_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_libface_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __construct($x1_or_that=null,$y1=null,$x2=null,$y2=null,$id=null,$face=null) {
		if (is_resource($x1_or_that) && get_resource_type($x1_or_that) === '_p_libface__Face') {
			$this->_cPtr=$x1_or_that;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_Face(); break;
		case 1: $this->_cPtr=new_Face($x1_or_that); break;
		case 2: $this->_cPtr=new_Face($x1_or_that,$y1); break;
		case 3: $this->_cPtr=new_Face($x1_or_that,$y1,$x2); break;
		case 4: $this->_cPtr=new_Face($x1_or_that,$y1,$x2,$y2); break;
		case 5: $this->_cPtr=new_Face($x1_or_that,$y1,$x2,$y2,$id); break;
		default: $this->_cPtr=new_Face($x1_or_that,$y1,$x2,$y2,$id,$face);
		}
	}

	function setX1($x1) {
		Face_setX1($this->_cPtr,$x1);
	}

	function setX2($x2) {
		Face_setX2($this->_cPtr,$x2);
	}

	function setY1($y1) {
		Face_setY1($this->_cPtr,$y1);
	}

	function setY2($y2) {
		Face_setY2($this->_cPtr,$y2);
	}

	function setId($id) {
		Face_setId($this->_cPtr,$id);
	}

	function setFace($face) {
		Face_setFace($this->_cPtr,$face);
	}

	function getFace() {
		return Face_getFace($this->_cPtr);
	}

	function getHeight() {
		return Face_getHeight($this->_cPtr);
	}

	function getWidth() {
		return Face_getWidth($this->_cPtr);
	}

	function getX1() {
		return Face_getX1($this->_cPtr);
	}

	function getX2() {
		return Face_getX2($this->_cPtr);
	}

	function getY1() {
		return Face_getY1($this->_cPtr);
	}

	function getY2() {
		return Face_getY2($this->_cPtr);
	}

	function getId() {
		return Face_getId($this->_cPtr);
	}
}

class LibFaceUtils {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_libface_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_libface_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	static function resizeToArea($img,$area,$ratio) {
		return LibFaceUtils_resizeToArea($img,$area,$ratio);
	}

	static function center($arg1) {
		return LibFaceUtils_center($arg1);
	}

	static function distance($arg1,$arg2) {
		return LibFaceUtils_distance($arg1,$arg2);
	}

	static function addScalar($src,$value) {
		return LibFaceUtils_addScalar($src,$value);
	}

	static function combine($src,$vector) {
		return LibFaceUtils_combine($src,$vector);
	}

	static function divVec($src,$value) {
		LibFaceUtils_divVec($src,$value);
	}

	static function getColoumn($src,$col) {
		return LibFaceUtils_getColoumn($src,$col);
	}

	static function mean($src) {
		return LibFaceUtils_mean($src);
	}

	static function multScalar($src,$value) {
		return LibFaceUtils_multScalar($src,$value);
	}

	static function printMatrix($src) {
		LibFaceUtils_printMatrix($src);
	}

	static function reshape($src) {
		return LibFaceUtils_reshape($src);
	}

	static function reverseOrder($src) {
		return LibFaceUtils_reverseOrder($src);
	}

	static function showImage($src_or_img,$title_or_faces=null,$scale=null,$title=null) {
		switch (func_num_args()) {
		case 1: LibFaceUtils_showImage($src_or_img); break;
		case 2: LibFaceUtils_showImage($src_or_img,$title_or_faces); break;
		case 3: LibFaceUtils_showImage($src_or_img,$title_or_faces,$scale); break;
		default: LibFaceUtils_showImage($src_or_img,$title_or_faces,$scale,$title);
		}
	}

	static function sqrVec($src) {
		LibFaceUtils_sqrVec($src);
	}

	static function stringToImage($data,$depth,$channels) {
		return LibFaceUtils_stringToImage($data,$depth,$channels);
	}

	static function stringToMatrix($data,$type) {
		return LibFaceUtils_stringToMatrix($data,$type);
	}

	static function subtract($src1,$src2) {
		return LibFaceUtils_subtract($src1,$src2);
	}

	static function sumVecToDouble($src) {
		return LibFaceUtils_sumVecToDouble($src);
	}

	static function transpose($src) {
		return LibFaceUtils_transpose($src);
	}

	static function charToIplImage($img,$width,$height,$step,$depth,$channels) {
		return LibFaceUtils_charToIplImage($img,$width,$height,$step,$depth,$channels);
	}

	static function copyRect($src,$rect) {
		return LibFaceUtils_copyRect($src,$rect);
	}

	static function scaledSection($src,$sourceRect,$scaleFactor_or_destSize) {
		return LibFaceUtils_scaledSection($src,$sourceRect,$scaleFactor_or_destSize);
	}

	static function imageToString($src) {
		return LibFaceUtils_imageToString($src);
	}

	static function matrixToString($src) {
		return LibFaceUtils_matrixToString($src);
	}

	function stringify($x) {
		return LibFaceUtils_stringify($this->_cPtr,$x);
	}

	function __construct($res=null) {
		if (is_resource($res) && get_resource_type($res) === '_p_libface__LibFaceUtils') {
			$this->_cPtr=$res;
			return;
		}
		$this->_cPtr=new_LibFaceUtils();
	}
}

class LibFace {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_libface_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_libface_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __construct($type_or_that=null,$configDir=null,$cascadeDir=null) {
		if (is_resource($type_or_that) && get_resource_type($type_or_that) === '_p_libface__LibFace') {
			$this->_cPtr=$type_or_that;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_LibFace(); break;
		case 1: $this->_cPtr=new_LibFace($type_or_that); break;
		case 2: $this->_cPtr=new_LibFace($type_or_that,$configDir); break;
		default: $this->_cPtr=new_LibFace($type_or_that,$configDir,$cascadeDir);
		}
	}

	function count() {
		return LibFace_count($this->_cPtr);
	}

	function detectFaces($image_or_filename_or_arr,$scaleFactor_or_width=null,$height=null,$step=null,$depth=null,$channels=null,$scaleFactor=null) {
		switch (func_num_args()) {
		case 1: $r=LibFace_detectFaces($this->_cPtr,$image_or_filename_or_arr); break;
		case 2: $r=LibFace_detectFaces($this->_cPtr,$image_or_filename_or_arr,$scaleFactor_or_width); break;
		case 3: $r=LibFace_detectFaces($this->_cPtr,$image_or_filename_or_arr,$scaleFactor_or_width,$height); break;
		case 4: $r=LibFace_detectFaces($this->_cPtr,$image_or_filename_or_arr,$scaleFactor_or_width,$height,$step); break;
		case 5: $r=LibFace_detectFaces($this->_cPtr,$image_or_filename_or_arr,$scaleFactor_or_width,$height,$step,$depth); break;
		case 6: $r=LibFace_detectFaces($this->_cPtr,$image_or_filename_or_arr,$scaleFactor_or_width,$height,$step,$depth,$channels); break;
		default: $r=LibFace_detectFaces($this->_cPtr,$image_or_filename_or_arr,$scaleFactor_or_width,$height,$step,$depth,$channels,$scaleFactor);
		}
		if (!is_resource($r)) return $r;
		switch (get_resource_type($r)) {
		case '_p_std__vectorT_libface__Face_p_t': return new FacePVector($r);
		default: return new FacePVector($r);
		}
	}

	function getConfig() {
		return LibFace_getConfig($this->_cPtr);
	}

	function getDetectionAccuracy() {
		return LibFace_getDetectionAccuracy($this->_cPtr);
	}

	function getRecommendedImageSizeForDetection($size=null) {
		switch (func_num_args()) {
		case 0: $r=LibFace_getRecommendedImageSizeForDetection($this->_cPtr); break;
		default: $r=LibFace_getRecommendedImageSizeForDetection($this->_cPtr,$size);
		}
		return $r;
	}

	function getRecommendedImageSizeForRecognition($size=null) {
		switch (func_num_args()) {
		case 0: $r=LibFace_getRecommendedImageSizeForRecognition($this->_cPtr); break;
		default: $r=LibFace_getRecommendedImageSizeForRecognition($this->_cPtr,$size);
		}
		return $r;
	}

	function loadConfig($dir_or_config) {
		return LibFace_loadConfig($this->_cPtr,$dir_or_config);
	}

	function recognise($img_or_filename_or_arr_or_faces,$faces_or_scaleFactor=null,$scaleFactor_or_width=null,$height=null,$step=null,$depth=null,$channels=null,$scaleFactor=null) {
		switch (func_num_args()) {
		case 1: $r=LibFace_recognise($this->_cPtr,$img_or_filename_or_arr_or_faces); break;
		case 2: $r=LibFace_recognise($this->_cPtr,$img_or_filename_or_arr_or_faces,$faces_or_scaleFactor); break;
		case 3: $r=LibFace_recognise($this->_cPtr,$img_or_filename_or_arr_or_faces,$faces_or_scaleFactor,$scaleFactor_or_width); break;
		case 4: $r=LibFace_recognise($this->_cPtr,$img_or_filename_or_arr_or_faces,$faces_or_scaleFactor,$scaleFactor_or_width,$height); break;
		case 5: $r=LibFace_recognise($this->_cPtr,$img_or_filename_or_arr_or_faces,$faces_or_scaleFactor,$scaleFactor_or_width,$height,$step); break;
		case 6: $r=LibFace_recognise($this->_cPtr,$img_or_filename_or_arr_or_faces,$faces_or_scaleFactor,$scaleFactor_or_width,$height,$step,$depth); break;
		case 7: $r=LibFace_recognise($this->_cPtr,$img_or_filename_or_arr_or_faces,$faces_or_scaleFactor,$scaleFactor_or_width,$height,$step,$depth,$channels); break;
		default: $r=LibFace_recognise($this->_cPtr,$img_or_filename_or_arr_or_faces,$faces_or_scaleFactor,$scaleFactor_or_width,$height,$step,$depth,$channels,$scaleFactor);
		}
		return $r;
	}

	function saveConfig($dir) {
		return LibFace_saveConfig($this->_cPtr,$dir);
	}

	function setDetectionAccuracy($value) {
		LibFace_setDetectionAccuracy($this->_cPtr,$value);
	}

	function update($filename_or_arr_or_img_or_faces,$faces_or_scaleFactor=null,$scaleFactor_or_width=null,$height=null,$step=null,$depth=null,$channels=null,$scaleFactor=null) {
		switch (func_num_args()) {
		case 1: $r=LibFace_update($this->_cPtr,$filename_or_arr_or_img_or_faces); break;
		case 2: $r=LibFace_update($this->_cPtr,$filename_or_arr_or_img_or_faces,$faces_or_scaleFactor); break;
		case 3: $r=LibFace_update($this->_cPtr,$filename_or_arr_or_img_or_faces,$faces_or_scaleFactor,$scaleFactor_or_width); break;
		case 4: $r=LibFace_update($this->_cPtr,$filename_or_arr_or_img_or_faces,$faces_or_scaleFactor,$scaleFactor_or_width,$height); break;
		case 5: $r=LibFace_update($this->_cPtr,$filename_or_arr_or_img_or_faces,$faces_or_scaleFactor,$scaleFactor_or_width,$height,$step); break;
		case 6: $r=LibFace_update($this->_cPtr,$filename_or_arr_or_img_or_faces,$faces_or_scaleFactor,$scaleFactor_or_width,$height,$step,$depth); break;
		case 7: $r=LibFace_update($this->_cPtr,$filename_or_arr_or_img_or_faces,$faces_or_scaleFactor,$scaleFactor_or_width,$height,$step,$depth,$channels); break;
		default: $r=LibFace_update($this->_cPtr,$filename_or_arr_or_img_or_faces,$faces_or_scaleFactor,$scaleFactor_or_width,$height,$step,$depth,$channels,$scaleFactor);
		}
		return $r;
	}
}

class Cascade {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'name') return Cascade_name_set($this->_cPtr,$value);
		if ($var === 'haarcasc') return Cascade_haarcasc_set($this->_cPtr,$value);
		if ($var === 'thisown') return swig_libface_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if (function_exists('Cascade_'.$var.'_set')) return true;
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		$func = 'Cascade_'.$var.'_get';
		if (function_exists($func)) {
			$r = call_user_func($func,$this->_cPtr);
			if (!is_resource($r)) return $r;
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			return new $c($r);
		}
		if ($var === 'thisown') return swig_libface_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}
	function __construct($h) {
		$this->_cPtr=$h;
	}
}

class Haarcascades {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_libface_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_libface_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __construct($path_or_that) {
		if (is_resource($path_or_that) && get_resource_type($path_or_that) === '_p_libface__Haarcascades') {
			$this->_cPtr=$path_or_that;
			return;
		}
		$this->_cPtr=new_Haarcascades($path_or_that);
	}

	function addCascade($newCascade_or_name,$newWeight) {
		return Haarcascades_addCascade($this->_cPtr,$newCascade_or_name,$newWeight);
	}

	function removeCascade($name_or_index) {
		Haarcascades_removeCascade($this->_cPtr,$name_or_index);
	}

	function setWeight($name_or_index,$weight) {
		Haarcascades_setWeight($this->_cPtr,$name_or_index,$weight);
	}

	function getWeight($name_or_index) {
		return Haarcascades_getWeight($this->_cPtr,$name_or_index);
	}

	function hasCascade($name) {
		return Haarcascades_hasCascade($this->_cPtr,$name);
	}

	function getCascade($name_or_index) {
		$r=Haarcascades_getCascade($this->_cPtr,$name_or_index);
		if (!is_resource($r)) return $r;
		switch (get_resource_type($r)) {
		case '_p_libface__CascadeStruct': return new Cascade($r);
		default: return new Cascade($r);
		}
	}

	function getSize() {
		return Haarcascades_getSize($this->_cPtr);
	}

	function clear() {
		Haarcascades_clear($this->_cPtr);
	}
}

class FaceDetect extends LibFaceDetectCore {
	public $_cPtr=null;

	function __set($var,$value) {
		if ($var === 'thisown') return swig_libface_php_alter_newobject($this->_cPtr,$value);
		LibFaceDetectCore::__set($var,$value);
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return LibFaceDetectCore::__isset($var);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_libface_php_get_newobject($this->_cPtr);
		return LibFaceDetectCore::__get($var);
	}

	function __construct($cascadeDir_or_that) {
		if (is_resource($cascadeDir_or_that) && get_resource_type($cascadeDir_or_that) === '_p_libface__FaceDetect') {
			$this->_cPtr=$cascadeDir_or_that;
			return;
		}
		$this->_cPtr=new_FaceDetect($cascadeDir_or_that);
	}

	function detectFaces($inputImage_or_filename) {
		$r=FaceDetect_detectFaces($this->_cPtr,$inputImage_or_filename);
		if (!is_resource($r)) return $r;
		switch (get_resource_type($r)) {
		case '_p_std__vectorT_libface__Face_p_t': return new FacePVector($r);
		default: return new FacePVector($r);
		}
	}

	function accuracy() {
		return FaceDetect_accuracy($this->_cPtr);
	}

	function setAccuracy($value) {
		FaceDetect_setAccuracy($this->_cPtr,$value);
	}

	static function getRecommendedImageSizeForDetection() {
		return FaceDetect_getRecommendedImageSizeForDetection();
	}
}

class Eigenfaces extends LibFaceRecognitionCore {
	public $_cPtr=null;

	function __set($var,$value) {
		if ($var === 'thisown') return swig_libface_php_alter_newobject($this->_cPtr,$value);
		LibFaceRecognitionCore::__set($var,$value);
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return LibFaceRecognitionCore::__isset($var);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_libface_php_get_newobject($this->_cPtr);
		return LibFaceRecognitionCore::__get($var);
	}

	function __construct($dir_or_that=null) {
		if (is_resource($dir_or_that) && get_resource_type($dir_or_that) === '_p_libface__Eigenfaces') {
			$this->_cPtr=$dir_or_that;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_Eigenfaces(); break;
		default: $this->_cPtr=new_Eigenfaces($dir_or_that);
		}
	}

	function count() {
		return Eigenfaces_count($this->_cPtr);
	}

	function getConfig() {
		return Eigenfaces_getConfig($this->_cPtr);
	}

	function loadConfig($config_or_dir) {
		return Eigenfaces_loadConfig($this->_cPtr,$config_or_dir);
	}

	function recognize($input) {
		return Eigenfaces_recognize($this->_cPtr,$input);
	}

	function saveConfig($dir) {
		return Eigenfaces_saveConfig($this->_cPtr,$dir);
	}

	function update($dataVector) {
		return Eigenfaces_update($this->_cPtr,$dataVector);
	}
}

class IntVector {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_libface_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_libface_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __construct($n=null) {
		if (is_resource($n) && get_resource_type($n) === '_p_std__vectorT_int_t') {
			$this->_cPtr=$n;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_IntVector(); break;
		default: $this->_cPtr=new_IntVector($n);
		}
	}

	function size() {
		return IntVector_size($this->_cPtr);
	}

	function capacity() {
		return IntVector_capacity($this->_cPtr);
	}

	function reserve($n) {
		IntVector_reserve($this->_cPtr,$n);
	}

	function clear() {
		IntVector_clear($this->_cPtr);
	}

	function push($x) {
		IntVector_push($this->_cPtr,$x);
	}

	function is_empty() {
		return IntVector_is_empty($this->_cPtr);
	}

	function pop() {
		return IntVector_pop($this->_cPtr);
	}

	function get($i) {
		return IntVector_get($this->_cPtr,$i);
	}

	function set($i,$val) {
		IntVector_set($this->_cPtr,$i,$val);
	}
}

class DoubleVector {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_libface_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_libface_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __construct($n=null) {
		if (is_resource($n) && get_resource_type($n) === '_p_std__vectorT_double_t') {
			$this->_cPtr=$n;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_DoubleVector(); break;
		default: $this->_cPtr=new_DoubleVector($n);
		}
	}

	function size() {
		return DoubleVector_size($this->_cPtr);
	}

	function capacity() {
		return DoubleVector_capacity($this->_cPtr);
	}

	function reserve($n) {
		DoubleVector_reserve($this->_cPtr,$n);
	}

	function clear() {
		DoubleVector_clear($this->_cPtr);
	}

	function push($x) {
		DoubleVector_push($this->_cPtr,$x);
	}

	function is_empty() {
		return DoubleVector_is_empty($this->_cPtr);
	}

	function pop() {
		return DoubleVector_pop($this->_cPtr);
	}

	function get($i) {
		return DoubleVector_get($this->_cPtr,$i);
	}

	function set($i,$val) {
		DoubleVector_set($this->_cPtr,$i,$val);
	}
}

class FloatVector {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_libface_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_libface_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __construct($n=null) {
		if (is_resource($n) && get_resource_type($n) === '_p_std__vectorT_float_t') {
			$this->_cPtr=$n;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_FloatVector(); break;
		default: $this->_cPtr=new_FloatVector($n);
		}
	}

	function size() {
		return FloatVector_size($this->_cPtr);
	}

	function capacity() {
		return FloatVector_capacity($this->_cPtr);
	}

	function reserve($n) {
		FloatVector_reserve($this->_cPtr,$n);
	}

	function clear() {
		FloatVector_clear($this->_cPtr);
	}

	function push($x) {
		FloatVector_push($this->_cPtr,$x);
	}

	function is_empty() {
		return FloatVector_is_empty($this->_cPtr);
	}

	function pop() {
		return FloatVector_pop($this->_cPtr);
	}

	function get($i) {
		return FloatVector_get($this->_cPtr,$i);
	}

	function set($i,$val) {
		FloatVector_set($this->_cPtr,$i,$val);
	}
}

class FaceVector {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_libface_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_libface_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __construct($n=null) {
		if (is_resource($n) && get_resource_type($n) === '_p_std__vectorT_libface__Face_t') {
			$this->_cPtr=$n;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_FaceVector(); break;
		default: $this->_cPtr=new_FaceVector($n);
		}
	}

	function size() {
		return FaceVector_size($this->_cPtr);
	}

	function capacity() {
		return FaceVector_capacity($this->_cPtr);
	}

	function reserve($n) {
		FaceVector_reserve($this->_cPtr,$n);
	}

	function clear() {
		FaceVector_clear($this->_cPtr);
	}

	function push($x) {
		FaceVector_push($this->_cPtr,$x);
	}

	function is_empty() {
		return FaceVector_is_empty($this->_cPtr);
	}

	function pop() {
		$r=FaceVector_pop($this->_cPtr);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (!class_exists($c)) {
				return new Face($r);
			}
			return new $c($r);
		}
		return $r;
	}

	function get($i) {
		$r=FaceVector_get($this->_cPtr,$i);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (!class_exists($c)) {
				return new Face($r);
			}
			return new $c($r);
		}
		return $r;
	}

	function set($i,$val) {
		FaceVector_set($this->_cPtr,$i,$val);
	}
}

class FacePVector {
	public $_cPtr=null;
	protected $_pData=array();

	function __set($var,$value) {
		if ($var === 'thisown') return swig_libface_php_alter_newobject($this->_cPtr,$value);
		$this->_pData[$var] = $value;
	}

	function __isset($var) {
		if ($var === 'thisown') return true;
		return array_key_exists($var, $this->_pData);
	}

	function __get($var) {
		if ($var === 'thisown') return swig_libface_php_get_newobject($this->_cPtr);
		return $this->_pData[$var];
	}

	function __construct($n=null) {
		if (is_resource($n) && get_resource_type($n) === '_p_std__vectorT_libface__Face_p_t') {
			$this->_cPtr=$n;
			return;
		}
		switch (func_num_args()) {
		case 0: $this->_cPtr=new_FacePVector(); break;
		default: $this->_cPtr=new_FacePVector($n);
		}
	}

	function size() {
		return FacePVector_size($this->_cPtr);
	}

	function capacity() {
		return FacePVector_capacity($this->_cPtr);
	}

	function reserve($n) {
		FacePVector_reserve($this->_cPtr,$n);
	}

	function clear() {
		FacePVector_clear($this->_cPtr);
	}

	function push($x) {
		FacePVector_push($this->_cPtr,$x);
	}

	function is_empty() {
		return FacePVector_is_empty($this->_cPtr);
	}

	function pop() {
		$r=FacePVector_pop($this->_cPtr);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (!class_exists($c)) {
				return new Face($r);
			}
			return new $c($r);
		}
		return $r;
	}

	function get($i) {
		$r=FacePVector_get($this->_cPtr,$i);
		if (is_resource($r)) {
			$c=substr(get_resource_type($r), (strpos(get_resource_type($r), '__') ? strpos(get_resource_type($r), '__') + 2 : 3));
			if (!class_exists($c)) {
				return new Face($r);
			}
			return new $c($r);
		}
		return $r;
	}

	function set($i,$val) {
		FacePVector_set($this->_cPtr,$i,$val);
	}
}


?>
